// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package v1alpha1

import (
	ackv1alpha1 "github.com/aws-controllers-k8s/runtime/apis/core/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// AccessEntrySpec defines the desired state of AccessEntry.
//
// An access entry allows an IAM principal (user or role) to access your cluster.
// Access entries can replace the need to maintain the aws-auth ConfigMap for
// authentication. For more information about access entries, see Access entries
// (https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html) in
// the Amazon EKS User Guide.
type AccessEntrySpec struct {
	AccessPolicies []*AssociateAccessPolicyInput `json:"accessPolicies,omitempty"`
	// The name of your cluster.

	ClusterName *string `json:"clusterName,omitempty"`

	ClusterRef *ackv1alpha1.AWSResourceReferenceWrapper `json:"clusterRef,omitempty"`
	// The value for name that you've specified for kind: Group as a subject in
	// a Kubernetes RoleBinding or ClusterRoleBinding object. Amazon EKS doesn't
	// confirm that the value for name exists in any bindings on your cluster. You
	// can specify one or more names.
	//
	// Kubernetes authorizes the principalArn of the access entry to access any
	// cluster objects that you've specified in a Kubernetes Role or ClusterRole
	// object that is also specified in a binding's roleRef. For more information
	// about creating Kubernetes RoleBinding, ClusterRoleBinding, Role, or ClusterRole
	// objects, see Using RBAC Authorization in the Kubernetes documentation (https://kubernetes.io/docs/reference/access-authn-authz/rbac/).
	//
	// If you want Amazon EKS to authorize the principalArn (instead of, or in addition
	// to Kubernetes authorizing the principalArn), you can associate one or more
	// access policies to the access entry using AssociateAccessPolicy. If you associate
	// any access policies, the principalARN has all permissions assigned in the
	// associated access policies and all permissions in any Kubernetes Role or
	// ClusterRole objects that the group names are bound to.

	KubernetesGroups []*string `json:"kubernetesGroups,omitempty"`
	// The ARN of the IAM principal for the AccessEntry. You can specify one ARN
	// for each access entry. You can't specify the same ARN in more than one access
	// entry. This value can't be changed after access entry creation.
	//
	// The valid principals differ depending on the type of the access entry in
	// the type field. The only valid ARN is IAM roles for the types of access entries
	// for nodes: . You can use every IAM principal type for STANDARD access entries.
	// You can't use the STS session principal type with access entries because
	// this is a temporary principal for each session and not a permanent identity
	// that can be assigned permissions.
	//
	// IAM best practices (https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#bp-users-federation-idp)
	// recommend using IAM roles with temporary credentials, rather than IAM users
	// with long-term credentials.

	// +kubebuilder:validation:Required

	PrincipalARN *string `json:"principalARN"`
	// Metadata that assists with categorization and organization. Each tag consists
	// of a key and an optional value. You define both. Tags don't propagate to
	// any other cluster or Amazon Web Services resources.

	Tags map[string]*string `json:"tags,omitempty"`
	// The type of the new access entry. Valid values are Standard, FARGATE_LINUX,
	// EC2_LINUX, and EC2_WINDOWS.
	//
	// If the principalArn is for an IAM role that's used for self-managed Amazon
	// EC2 nodes, specify EC2_LINUX or EC2_WINDOWS. Amazon EKS grants the necessary
	// permissions to the node for you. If the principalArn is for any other purpose,
	// specify STANDARD. If you don't specify a value, Amazon EKS sets the value
	// to STANDARD. It's unnecessary to create access entries for IAM roles used
	// with Fargate profiles or managed Amazon EC2 nodes, because Amazon EKS creates
	// entries in the aws-auth ConfigMap for the roles. You can't change this value
	// once you've created the access entry.
	//
	// If you set the value to EC2_LINUX or EC2_WINDOWS, you can't specify values
	// for kubernetesGroups, or associate an AccessPolicy to the access entry.

	Type *string `json:"type,omitempty"`
	// The username to authenticate to Kubernetes with. We recommend not specifying
	// a username and letting Amazon EKS specify it for you. For more information
	// about the value Amazon EKS specifies for you, or constraints before specifying
	// your own username, see Creating access entries (https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html#creating-access-entries)
	// in the Amazon EKS User Guide.

	Username *string `json:"username,omitempty"`
}

// AccessEntryStatus defines the observed state of AccessEntry
type AccessEntryStatus struct {
	// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
	// that is used to contain resource sync state, account ownership,
	// constructed ARN for the resource
	// +kubebuilder:validation:Optional
	ACKResourceMetadata *ackv1alpha1.ResourceMetadata `json:"ackResourceMetadata"`
	// All CRs managed by ACK have a common `Status.Conditions` member that
	// contains a collection of `ackv1alpha1.Condition` objects that describe
	// the various terminal states of the CR and its backend AWS service API
	// resource
	// +kubebuilder:validation:Optional
	Conditions []*ackv1alpha1.Condition `json:"conditions"`
	// The Unix epoch timestamp at object creation.
	// +kubebuilder:validation:Optional
	CreatedAt *metav1.Time `json:"createdAt,omitempty"`
	// The Unix epoch timestamp for the last modification to the object.
	// +kubebuilder:validation:Optional
	ModifiedAt *metav1.Time `json:"modifiedAt,omitempty"`
}

// AccessEntry is the Schema for the AccessEntries API
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="CLUSTER",type=string,priority=0,JSONPath=`.spec.clusterName`
// +kubebuilder:printcolumn:name="TYPE",type=string,priority=0,JSONPath=`.spec.type`
// +kubebuilder:printcolumn:name="USERNAME",type=string,priority=0,JSONPath=`.spec.username`
// +kubebuilder:printcolumn:name="PRINCIPALARN",type=string,priority=1,JSONPath=`.spec.principalARN`
// +kubebuilder:printcolumn:name="Synced",type="string",priority=0,JSONPath=".status.conditions[?(@.type==\"ACK.ResourceSynced\")].status"
// +kubebuilder:printcolumn:name="Age",type="date",priority=0,JSONPath=".metadata.creationTimestamp"
type AccessEntry struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AccessEntrySpec   `json:"spec,omitempty"`
	Status            AccessEntryStatus `json:"status,omitempty"`
}

// AccessEntryList contains a list of AccessEntry
// +kubebuilder:object:root=true
type AccessEntryList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AccessEntry `json:"items"`
}

func init() {
	SchemeBuilder.Register(&AccessEntry{}, &AccessEntryList{})
}
